<!--
 * @Author: your name
 * @Date: 2022-03-16 06:57:36
 * @LastEditTime: 2022-04-25 18:55:07
 * @LastEditors: Please set LastEditors
 * @Description: 打开koroFileHeader查看配置 进行设置: https://github.com/OBKoro1/koro1FileHeader/wiki/%E9%85%8D%E7%BD%AE
 * @FilePath: /fe_interview/算法/算法思想.md
-->
1. kmp算法的核心是：避免主串i指针的回溯，同时让模式串指针j能移动到正确的位置
暴力解法的缺点：i指针回溯，j指针回溯，模式串回溯

kmp算法可以做到i指针不回溯（不动），模式串不回溯（向前移动），j指针回溯到正确位置。所以取决于模式串的移动位置和j指针的移动位置，模式串的前移位置又和j指针的移动位置相关。抽象出来就是失配时找匹配串的最长公共前后缀，匹配串前缀移动到后缀的位置，也就是j指针的位置为最长公共前后缀的长度+1的位置
next数组就是记录主串不匹配的位置i（i实际上是匹配串失配时对应的索引位置），和匹配串指针移动位置j的关系，next[i] = j，而这个不匹配的位置也在匹配串同时出现，最终转化成匹配串上不匹配的位置和匹配串指针j的移动位置关系

next数组为了方便处理，通常索引0的位置不放数据
事实上，next[i] = 第i位前的，最长公共前后缀长度加1

2. 动态规划就是避免重复节点的计算，加速计算的过程，用字典或者hash表保存计算的中间结果，也称为记忆化搜索，也是大家经常说的动态规划是空间换时间，也有人叫带备忘录的递归，或者递归树的剪枝，就是不需要对一些树的子节点进行重复计算了
递归算法也可以改成非递归的形式，也叫做迭代的形式，这样可以直观分析算法的复杂度，也可以避免递归时函数调用的开销
穷举或者暴力搜索->记忆化搜索或者剪枝->改成迭代形式

3. leetcode44题是通配符匹配，注意区别于正则匹配（正则匹配时，.*？都表示量词）

4. 贪心思想：通过局部最优解找全局最优解
