## 网关
提供安全、流控、过滤、缓存、计费、监控等API管理功能
单体应用：浏览器发起请求到单体应用所在的机器，应用从数据库查询数据原路返回给浏览器，对单体应用来说是可以不用网关的
微服务：微服务的应用是部署在不同机房、不同地区、不同域名下的。此时客户端想要请求对应的服务，都需要知道机器的具体IP或域名；当微服务实例众多时，对客户端来说就难以维护。此时就有了网关，客户端相关的请求直接发送到网关，由网关根据请求标识解析判断出具体的微服务网址，再把请求发送到服务实例上。这其中的记忆功能就全部交由网关来操作了
客户端向Spring Cloud Gateway发出请求。然后在Gateway Handler Mapping 中找到与请求相匹配的路由，将其发送到GatewayWeb Handler。

Handler再通过指定的过滤器链来将请求发送到我们实际的服务执行业务逻辑，然后返回。

过滤器之间用虚线分开是因为过滤器可能会在发送代理请求之前(“pre”)或之后(“post"）执行业务逻辑。

Filter在“pre”类型的过滤器可以做参数校验、权限校验、流量监控、日志输出、协议转换等，
在“post”类型的过滤器中可以做响应内容、响应头的修改，日志的输出，流量监控等有着非常重要的作用。

核心逻辑：路由转发 + 执行过滤器链。
## 数据一致性
我可以和大家聊一个共识算法呀。

说到共识算法，大家首先想到的应该都是 Raft、Paxos、Zab 算法这类理解起来比较困难的强一致性算法。

但是还有一个弱一致性的共识算法比较好理解，Gossip 协议。

Gossip，先看这个单词，圈起来，要考的啊，这是一个六级词汇，也是考研单词，意思是“流言蜚语”。
“熵”的通俗理解就是“混乱程度”。

比如你的房间，如果你不去整理那么各自物品的摆放就会越来越混乱，也就是越来越“熵”。而你整理房间的这个操作就是“反熵”。
传谣”和“反熵”的差别在于只传递新信息或者发生了变更的信息，而不需要传递全量的信息。
gossip原本用于分布式数据库中节点同步数据使用，后被广泛用于数据库复制、信息扩散、集群成员身份确认、故障探测等。
Gossip 协议最终目的是将数据分发到网络中的每一个节点。根据不同的具体应用场景，网络中两个节点之间存在三种通信方式：推送模式、拉取模式、Push/Pull。

Push: 节点 A 将数据 (key,value,version) 及对应的版本号推送给 B 节点，B 节点更新 A 中比自己新的数据
Pull：A 仅将数据 key, version 推送给 B，B 将本地比 A 新的数据（Key, value, version）推送给 A，A 更新本地
Push/Pull：与 Pull 类似，只是多了一步，A 再将本地比 B 新的数据推送给 B，B 则更新本地
如果把两个节点数据同步一次定义为一个周期，则在一个周期内，Push 需通信 1 次，Pull 需 2 次，Push/Pull 则需 3 次。虽然消息数增加了，但从效果上来讲，Push/Pull 最好，理论上一个周期内可以使两个节点完全一致。直观上，Push/Pull 的收敛速度也是最快的。
## 云原生
https://zhuanlan.zhihu.com/p/512427288
spring cloud + k8s + iaas
confluence	英[ˈkɒnfluəns]
美[ˈkɑːnfluəns]
n.	汇流; (河流的)汇合处; 汇流处; 交汇处; (事物的)汇合; 汇集;
